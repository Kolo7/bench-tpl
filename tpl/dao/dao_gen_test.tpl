// Code generated by goctl. DO NOT EDIT.
package {{.lowerPkgName}}

import (
	"context"
	"testing"
    "fmt"

	"git.imgo.tv/ft/go-ceres/pkg/db/mysql"
	"github.com/DATA-DOG/go-sqlmock"
	"github.com/Kolo7/bench-tpl/output/internal/model"
	"github.com/brianvoe/gofakeit"
	gomyql "github.com/go-sql-driver/mysql"
	"github.com/jinzhu/gorm"
	"github.com/stretchr/testify/assert"
)

func TestDao_GetAll{{.upperTableName}}(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	countRows := sqlmock.NewRows([]string{"count"}).AddRow(2)
	mock.ExpectQuery(
		"SELECT COUNT(*) as count FROM (SELECT * FROM {{.tableName}}) AS t",
	).WillReturnRows(countRows)

	mainRows := sqlmock.NewRows([]string{"id"}).
		AddRow(gofakeit.Number(1, 10)).
		AddRow(gofakeit.Number(1, 10))
	mock.ExpectQuery(
		"SELECT * FROM {{.tableName}} ORDER BY ? LIMIT ? OFFSET ?",
	).WithArgs("id asc", 10, 0).WillReturnRows(mainRows)

	records, total, err := dao.GetAll{{.upperTableName}}(context.Background(), 1, 10, "id ASC")
	assert.NoError(t, err, "expected no error")
	assert.Len(t, records, 2, "expected 2 records")
	assert.Equal(t, int64(2), total, "expected total 2")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}

func TestDao_{{.upperTableName}}FindOne_Success(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	arg := gofakeit.Number(1, 10)
	mock.ExpectQuery("SELECT * FROM {{.tableName}} WHERE id = ?").WithArgs(arg).WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(arg))

	record, err := dao.{{.upperTableName}}FindOne(context.Background(), int64(arg))
	assert.NoError(t, err, "expected no error")
	assert.NotNil(t, record, "expected record not nil")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}

func TestDao_{{.upperTableName}}FindOne_Error(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	arg := gofakeit.Number(1, 10)
	mock.ExpectQuery("SELECT * FROM {{.tableName}} WHERE id = ?").WithArgs(arg).WillReturnError(fmt.Errorf("error"))

	_, err = dao.{{.upperTableName}}FindOne(context.Background(), int64(arg))
	assert.ErrorIs(t, err, ErrNotFound, "expected error")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}

func TestDao_{{.upperTableName}}Insert_Success(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	arg := &model.{{.upperTableName}}{}

	mock.ExpectExec(
		fmt.Sprintf("INSERT INTO {{.tableName}} (%s) VALUES (%s)", {{.lowerTableName}}RowsExpectAutoSet, {{.lowerTableName}}AutoPlaceHolder),
	).WithArgs({{range $i, $field := .tableColumnUpperFields}}{{if not (inExcludedFields $field)}}arg.{{.}}{{if not (eq $i (sub (len $.tableColumnUpperFields) 1))}}, {{end}}{{end}}{{end}}).WillReturnResult(sqlmock.NewResult(1, 1))

	err = dao.{{.upperTableName}}Insert(context.Background(), arg)
	assert.NoError(t, err, "expected no error")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}

func TestDao_{{.upperTableName}}Insert_Error(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	arg := &model.{{.upperTableName}}{}

	mock.ExpectExec(
		fmt.Sprintf("INSERT INTO {{.tableName}} (%s) VALUES (%s)", {{.lowerTableName}}RowsExpectAutoSet, {{.lowerTableName}}AutoPlaceHolder),
	).WithArgs({{range $i, $field := .tableColumnUpperFields}}{{if not (inExcludedFields $field)}}arg.{{.}}{{if not (eq $i (sub (len $.tableColumnUpperFields) 1))}}, {{end}}{{end}}{{end}}).WillReturnError(&gomyql.MySQLError{Number: 1062})

	err = dao.{{.upperTableName}}Insert(context.Background(), arg)
	assert.ErrorIs(t, err, ErrUniqueConflict, "expected error")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}

func TestDao_{{.upperTableName}}Update_Success(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	arg := &model.{{.upperTableName}}{}

	mock.ExpectExec(
		fmt.Sprintf("UPDATE {{.tableName}} SET %s WHERE id = ?", {{.lowerTableName}}RowsWithPlaceHolder),
	).WithArgs({{range $i, $field := .tableColumnUpperFields}}{{if not (inExcludedFields $field)}}arg.{{.}},{{end}}{{end}} arg.{{.tableUpperPrimaryKeyField}}).WillReturnResult(sqlmock.NewResult(1, 1))

	err = dao.{{.upperTableName}}Update(context.Background(), arg)
	assert.NoError(t, err, "expected no error")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}

func TestDao_{{.upperTableName}}Update_Error(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	arg := &model.{{.upperTableName}}{}

	mock.ExpectExec(
		fmt.Sprintf("UPDATE {{.tableName}} SET %s WHERE id = ?", {{.lowerTableName}}RowsWithPlaceHolder),
	).WithArgs({{range $i, $field := .tableColumnUpperFields}}{{if not (inExcludedFields $field)}}arg.{{.}},{{end}}{{end}} arg.{{.tableUpperPrimaryKeyField}}).WillReturnError(&gomyql.MySQLError{Number: 1062})

	err = dao.{{.upperTableName}}Update(context.Background(), arg)
	assert.ErrorIs(t, err, ErrUniqueConflict, "expected error")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}

func TestDao_{{.upperTableName}}Delete_Success(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}
	ormDB = &mysql.OrmDb{}
	ormDB.DB, err = gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to create gorm db: %v", err)
	}
	dao := &Dao{db: ormDB.DB}

	arg := gofakeit.Number(1, 10)
	mock.ExpectExec("DELETE FROM {{.tableName}} WHERE id = ?").WithArgs(arg).WillReturnResult(sqlmock.NewResult(1, 1))

	err = dao.{{.upperTableName}}Delete(context.Background(), int64(arg))
	assert.NoError(t, err, "expected no error")

	assert.NoError(t, mock.ExpectationsWereMet(), "unfulfilled expectations")
}
